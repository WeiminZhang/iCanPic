/*****************************************************************************
*	GSI a socket interface for Micro-controllers and Controller Area Network *
*   Copyright (C) 2014 Glenn Self                                            *
*                                                                            *
*   This program is free software: you can redistribute it and/or modify     *
*   it under the terms of the GNU General Public License as published by     *
*   the Free Software Foundation, either version 3 of the License, or        *
*   (at your option) any later version.                                      *
*                                                                            *
*    This program is distributed in the hope that it will be useful,         *
*    but WITHOUT ANY WARRANTY; without even the implied warranty of          *
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
*    GNU General Public License for more details.                            *
*                                                                            *
*    You should have received a copy of the GNU General Public License       *
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
*****************************************************************************/
/////////////////////////////////////////////////////////////////////////////
// Name:        GSIClientTestframe.cpp
// Purpose:
// Author:
// Modified by:
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (Personal Edition), 27/02/2007 17:01:15

#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
#pragma implementation "GSIClientTestframe.h"
#endif

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

///@begin includes
#include "exitdialog.h"
#include "opensocketsession.h"
#include "opennodeDialog.h"
#include "CloseNodeDialog.h"
#include "SetDeviceDialog.h"
#include "gsiclientnbpanel.h"
////@end includes


//#include "wx/socket.h"
//#include "../socket/gsi.hpp"
//#include "../socket/gsidefs.h"
//#include "../socket/socket.hpp"
//#include <gsExcept.hpp>

#include "GSIClientTestframe.h"
#include "GSIClientNBPanel.h"
#include "GSIClientCommands.hpp"
#include "gsi-common/include/record.hpp"
#include "client.hpp"
#include "gsi-common/include/rs232defs.h"
#include "gsi-common/include/helper.hpp"

////@begin XPM images
////@end XPM images

#if __VISUALC__
	#ifdef _DEBUG
		#define _CRTDBG_MAP_ALLOC
		#include <crtdbg.h>
		#define DEBUG_NEW new(_NORMAL_BLOCK ,__FILE__, __LINE__)
	#else
		#define DEBUG_NEW new
	#endif
#endif
#if __GNUC__
    #define DEBUG_NEW new
#endif



/*!
 * GSIClientTestFrame type definition
 */

IMPLEMENT_CLASS( GSIClientTestFrame, wxFrame )

/*!
 * GSIClientTestFrame event table definition
 */

BEGIN_EVENT_TABLE( GSIClientTestFrame, wxFrame )

////@begin GSIClientTestFrame event table entries
    EVT_MENU( GSI_ID_CLIENT_TEST_MENU_EXIT, GSIClientTestFrame::OnGsiIdClientTestMenuExitClick )

    EVT_MENU( GSI_ID_CLIENT_TEST_MENU_OPEN_SESSION, GSIClientTestFrame::OnGsiIdClientTestMenuOpenSessionClick )

    EVT_MENU( GSI_ID_CLIENT_TEST_MENU_CLOSE_SESSION, GSIClientTestFrame::OnGsiIdClientTestMenuCloseSessionClick )

    EVT_MENU( GSI_ID_CLIENT_TEST_MENU_OPEN_NODE, GSIClientTestFrame::OnGsiIdClientTestMenuOpenNodeClick )

    EVT_MENU( GSI_ID_CLIENT_TEST_MENU_CLOSE_NODE, GSIClientTestFrame::OnGsiIdClientTestMenuCloseNodeClick )

    EVT_MENU( GSI_ID_CLIENT_TEST_MENU_OPEN_DEVICE, GSIClientTestFrame::OnGsiIdClientTestMenuOpenDeviceClick )

    EVT_MENU( GSI_ID_CLIENT_TEST_MENU_CLOSE_DEVICE, GSIClientTestFrame::OnGsiIdClientTestMenuCloseDeviceClick )

    EVT_MENU( GSI_ID_CLIENT_TEST_DEBUG_MENU_0, GSIClientTestFrame::OnGsiIdClientTestDebugMenu0Click )

    EVT_MENU( GSI_ID_CLIENT_TEST_DEBUG_MENU_1, GSIClientTestFrame::OnGsiIdClientTestDebugMenu1Click )

////@end GSIClientTestFrame event table entries

//GS errors in following line probably emanate from void OnGSISocketEvent(wxCommandEvent& event);
//probably using the wrong event type

    EVT_GSI_SOCKET_COMMAND(wxID_ANY, GSIClientTestFrame::OnGSISocketEvent)			//custom event from GSIClient
//Don't place SOCKET_RECORD_RECEIVED events here, otherwise they will not be handled by
//the individual notbook panels. See GSIClientNBPanell.cpp for events going to
//nodes

    EVT_CLOSE(GSIClientTestFrame::OnCloseWindow)


END_EVENT_TABLE()


/*!
 * GSIClientTestFrame constructors
 */

GSIClientTestFrame::GSIClientTestFrame()
{
    Init();
	//wxLEDNumberCtrl led;
}

GSIClientTestFrame::GSIClientTestFrame( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{


    Init();
    Create( parent, id, caption, pos, size, style );

	m_MenuSocket->Enable(GSI_ID_CLIENT_TEST_MENU_OPEN_SESSION, true);
    m_MenuSocket->Enable(GSI_ID_CLIENT_TEST_MENU_CLOSE_SESSION, false);

}

/*!
 * GSIClientTestFrame creator
 */

bool GSIClientTestFrame::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{

    try
    {
        ////@begin GSIClientTestFrame creation
    wxFrame::Create( parent, id, caption, pos, size, style );

    CreateControls();
    Centre();
        ////@end GSIClientTestFrame creation

    }
    catch (gsException &exc)
    {
        wxString s;
        s.Printf("Exception: %s. Error code=%i",exc.GetUserString().c_str(),exc.GetErrorCode());
        wxMessageBox(_(s),
               _("Error"),
               wxOK | wxICON_EXCLAMATION, this);
    }
    catch(...)
    {
         wxMessageBox(_("Unhandled exception"),
               _("Error"),
               wxOK | wxICON_EXCLAMATION, this);
    }

    return true;
}

/*!
 * GSIClientTestFrame destructor
 */

GSIClientTestFrame::~GSIClientTestFrame()
{
////@begin GSIClientTestFrame destruction
////@end GSIClientTestFrame destruction
}

/*!
 * Member initialisation
 */

void GSIClientTestFrame::Init()
{
////@begin GSIClientTestFrame member initialisation
    m_Notebook = NULL;
    m_MenuFile = NULL;
    m_MenuSocket = NULL;
    m_MenuNode = NULL;
    m_MenuDebug = NULL;
////@end GSIClientTestFrame member initialisation
    for(int i=0;i<GSIMaxNumNodes;i++)
    {
        m_NBPanelDataArray[i]=NULL;
    }
    m_deviceId=-1;                          //set by result of a choice dialog to >0
	m_numPanelsOpen=0;
	m_numSocketConnections=0;
}
/*!
 * Control creation for GSIClientTestFrame
 */

void GSIClientTestFrame::CreateControls()
{

    int node=GSI_NODE_THIS;

////@begin GSIClientTestFrame content construction
    // Generated by DialogBlocks, 17/06/2008 09:29:25 (Personal Edition)

    GSIClientTestFrame* itemFrame1 = this;

    wxMenuBar* menuBar = new wxMenuBar;
    m_MenuFile = new wxMenu;
    m_MenuFile->Append(GSI_ID_CLIENT_TEST_MENU_EXIT, _("E&xit"), _T(""), wxITEM_NORMAL);
    menuBar->Append(m_MenuFile, _("&File"));
    m_MenuSocket = new wxMenu;
    m_MenuSocket->Append(GSI_ID_CLIENT_TEST_MENU_OPEN_SESSION, _("&Open session"), _T(""), wxITEM_NORMAL);
    m_MenuSocket->AppendSeparator();
    m_MenuSocket->Append(GSI_ID_CLIENT_TEST_MENU_TEST_GSI, _("Test GSI &1"), _T(""), wxITEM_NORMAL);
    m_MenuSocket->AppendSeparator();
    m_MenuSocket->Append(GSI_ID_CLIENT_TEST_MENU_CLOSE_SESSION, _("&Close session"), _T(""), wxITEM_NORMAL);
    menuBar->Append(m_MenuSocket, _("&Socket"));
    m_MenuNode = new wxMenu;
    m_MenuNode->Append(GSI_ID_CLIENT_TEST_MENU_OPEN_NODE, _("&Open node on device"), _T(""), wxITEM_NORMAL);
    m_MenuNode->Append(GSI_ID_CLIENT_TEST_MENU_CLOSE_NODE, _("&Close node"), _T(""), wxITEM_NORMAL);
    m_MenuNode->Append(GSI_ID_CLIENT_TEST_MENU_OPEN_DEVICE, _("Open &device"), _T(""), wxITEM_NORMAL);
    m_MenuNode->Append(GSI_ID_CLIENT_TEST_MENU_CLOSE_DEVICE, _("C&lose device"), _T(""), wxITEM_NORMAL);
    m_MenuNode->Enable(GSI_ID_CLIENT_TEST_MENU_CLOSE_DEVICE, false);
    menuBar->Append(m_MenuNode, _("&Node"));
    m_MenuDebug = new wxMenu;
    m_MenuDebug->Append(GSI_ID_CLIENT_TEST_DEBUG_MENU_0, _("Debug test &1"), _T(""), wxITEM_NORMAL);
    m_MenuDebug->Append(GSI_ID_CLIENT_TEST_DEBUG_MENU_1, _("Debug test &2"), _T(""), wxITEM_NORMAL);
    menuBar->Append(m_MenuDebug, _("&Debug"));
    itemFrame1->SetMenuBar(menuBar);

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemFrame1->SetSizer(itemBoxSizer2);

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(itemBoxSizer3, 1, wxGROW|wxALL, 5);

    m_Notebook = new wxNotebook( itemFrame1, GSI_ID_CLIENT_TEST_MAIN_NOTEBOOK, wxDefaultPosition, wxDefaultSize, wxBK_DEFAULT );
    m_Notebook->SetHelpText(_("Help text"));
    if (GSIClientTestFrame::ShowToolTips())
        m_Notebook->SetToolTip(_("Help text"));

    itemBoxSizer3->Add(m_Notebook, 1, wxGROW|wxALL, 5);

    wxStatusBar* itemStatusBar22 = new wxStatusBar( itemFrame1, GSI_ID_CLIENT_TEST_STATUSBAR1, wxST_SIZEGRIP|wxNO_BORDER );
    itemStatusBar22->SetFieldsCount(2);
    itemFrame1->SetStatusBar(itemStatusBar22);

////@end GSIClientTestFrame content construction

    GSIClientNBPanel * panel = DEBUG_NEW GSIClientNBPanel(NULL,node, m_Notebook, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSUNKEN_BORDER|wxTAB_TRAVERSAL );
    wxString s("none");
    m_Notebook->AddPage(panel, s);
}

/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_MENU_OPEN_SESSION
 */



/********************************************************************
Open a new notebook panel attached to a node
return the node handle or GSINotAValidNodeHandle on failure
*********************************************************************/
GSINodeHandle GSIClientTestFrame::NewNode()
{

errorType rv=errNone;
GSIClientNBPanel * panel;
GSIClientNBPanelData *pd;

    panel=(GSIClientNBPanel *)GetNotebook()->GetCurrentPage();
    pd=panel->GetData();

    if(! pd->GetSocketClient().IsConnected())
    {
        errorType rv=panel->OpenSocket();
        if(rv)
            return GSINotAValidNodeHandle;
    }

    OpenNodeDialog* window = DEBUG_NEW OpenNodeDialog(this, GSI_ID_CLIENT_TEST_OPEN_NODE_DIALOG, _("OpenNode"));
    int returnValue = window->ShowModal();
    if(returnValue == wxID_OK)
    {
        GSINodeHandle node=window->GetNode();
        pd->SetNodeHandle(node);
        //panel holds the allocated panel, if a new (rather than default) then m_noNodesOpen will be false
        //if(m_deviceId==-1)
		if(pd->GetDeviceHandle() == GSINotAValidDevHandle)
        {
            wxString dev;
            rv=OpenDevice(*pd);      //node this device is attaced to
        }
        if(rv != errNone)
        {
            return GSINotAValidNodeHandle;
        }

        rv=OpenNode(*pd);
        if (rv != errNone) //(rv != GSISocketReturnData::GSI_SUCCESS)
            return GSINotAValidNodeHandle;
		rv=AddNBPanel(*pd);

    }
//Probably need to keep an array of ints mapping which node is on which page
//better still an array of structures holding TextCtrl, LCD, KeyPad control pointers
//that way we can access them very quickly and easily
    //panel->SetNode();
    if(rv==errNone)
    {
        GSIClientNBPanelData * const data=panel->GetData();
        UpdateNBPage(*data);             //using the supplied data object. Setup the notebook page
        panel->GetData()->GetSocketClient().SetNodeHandle(panel->GetData()->GetNodeHandle());
    }
    window->Destroy();

	return (pd->GetNodeHandle());
}

/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_MENU_OPEN_NODE
 */

void GSIClientTestFrame::OnGsiIdClientTestMenuOpenNodeClick( wxCommandEvent& event )
{

	event;
	GSINodeHandle node=NewNode();
	node;
}


/*!
 * errorType  GSIClientTestFrame::OpenNode(GSIClientNBPanelData &panel_data)
 */
errorType  GSIClientTestFrame::OpenNode(GSIClientNBPanelData &panel_data)
{
errorType rv=errNone;

    GSIClientCommandAddNodeXXX cmd(panel_data.GetSocketClient(),panel_data.GetNodeHandle(),panel_data.GetDeviceHandle(),panel_data.GetStatusTextCtrl());

    if(cmd.GetReturnCode() !=  GSISocketReturnData::GSI_SUCCESS)
    {
        int rc=cmd.GetReturnCode();
		if(rc)		//server returned an error
		{
			wxString es;
			es=cmd.GetErrorString();

			wxString s="Server returned: ";

			wxMessageBox(_(s+es),
			_("Server returned an error:"),
			wxOK | wxICON_EXCLAMATION, this);

		}
		panel_data.SetNodeHandle(GSINotAValidNodeHandle);
		rv=errFail;
    }
    else
    {       //success
        //m_node=cmd.GetNodeHandle();
        panel_data.SetNodeHandle(cmd.GetNodeHandle());
    }

    return rv;
}

/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_MENU_SET_DEVICE
 */

void GSIClientTestFrame::OnGsiIdClientTestMenuOpenDeviceClick( wxCommandEvent& event )
{
	event;
    GSIClientNBPanel & panel= *(GSIClientNBPanel* ) m_Notebook->GetCurrentPage();

    if(! panel.GetData()->GetSocketClient().IsConnected())
    {
        errorType rv=panel.OpenSocket();
        if(rv)
            return;
    }

    OpenDevice(*panel.GetData());

}


errorType  GSIClientTestFrame::OpenDevice(GSIClientNBPanelData &panel_data)
{
errorType rv=errNone;

    //if(panel_data.GetDeviceName().IsEmpty())
	if(panel_data.GetDeviceHandle() == GSINotAValidDevHandle)
    {
        SetDeviceDialog* window = DEBUG_NEW SetDeviceDialog(this, GSI_ID_CLIENT_TEST_SETDEVICE_DIALOG, _("Set device"));
        int returnValue = window->ShowModal();
        if(returnValue == wxID_OK)
        {
            m_deviceId=window->m_Choice->GetCurrentSelection();
            wxString DevS;
            //wxTextCtrl *textCtrl= panel_data.GetStatusTextCtrl();

            DevS=window->m_Choice->GetString(m_deviceId);
			GSIClientCommandOpenDeviceXXX OpenDevice(panel_data.GetSocketClient(),DevS);
            if(OpenDevice.GetReturnCode() !=  GSISocketReturnData::GSI_SUCCESS)
            {
                int rc=OpenDevice.GetReturnCode();
				if(rc)
				{
					//wxFAIL_MSG("Do something with this error!");
					wxString es;
					es=OpenDevice.GetErrorString();

					wxString s="Server returned: ";

					wxMessageBox(_(s+es),
					_("Server returned an error:"),
					wxOK | wxICON_EXCLAMATION, this);

				}
                rv=errFail;
            }
            else
            {       //success
                m_deviceHandle=OpenDevice.GetDeviceHandle();
                panel_data.SetDeviceName(DevS);
                panel_data.SetDeviceHandle(m_deviceHandle); //redundancy as we would like to support multiple devices (one per notebook panel)

                m_MenuNode->Enable(GSI_ID_CLIENT_TEST_MENU_CLOSE_DEVICE, true);

            }
        }
        window->Destroy();
    }

    return rv;
}



/*!
 * Should we show tooltips?
 */

bool GSIClientTestFrame::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap GSIClientTestFrame::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin GSIClientTestFrame bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end GSIClientTestFrame bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon GSIClientTestFrame::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin GSIClientTestFrame icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end GSIClientTestFrame icon retrieval
}

/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_MENU_OPEN_SESSION
 */

void GSIClientTestFrame::OnGsiIdClientTestMenuOpenSessionClick( wxCommandEvent& event )
{

    // Before editing this code, remove the block markers.
//GSISocketClient *sock;
//sock;

	event;
    errorType rv=OpenSocketSession();
	if(rv)
	{
		wxFAIL_MSG("Do something with this error!");
	}
}

/*!
 * errorType GSIClientTestFrame::OpenSocketSession()
*/

errorType GSIClientTestFrame::OpenSocketSession()
{
    GSIClientNBPanel & panel= *(GSIClientNBPanel* ) m_Notebook->GetCurrentPage();

    if(! panel.GetData()->GetSocketClient().IsConnected())
    {
        errorType rv=panel.OpenSocket();
        if(rv)
            return rv;		//some form of socket or connection error
    }

    //OpenDevice(*panel.GetData());

	if(! panel.GetData()->GetSocketClient().IsConnected())
	{	//User must have cancelled
		return errUserCancel;
	}
    return errNone;
}




/*************************************************************************************
void GSIClientTestFrame::OpenConnection()
*************************************************************************************/

errorType GSIClientTestFrame::OpenConnection(int sock_address, const wxString & host)
{
	host;
	sock_address;
    return errFail;
}


/************************************************************
bool GSIClientTestFrame::ProcessEvent(wxEvent& event)
needed so that we can catch exceptions in event handlers
************************************************************/
bool GSIClientTestFrame::ProcessEvent(wxEvent& event)
{
    try
    {
        return wxFrame::ProcessEvent(event);
    }

    catch (gsException &exc)
    {
        wxString s;
        s.Printf("Exception: %s. Error code=%i\n%s",exc.GetUserString().c_str(),exc.GetErrorCode(),exc.GetString().c_str());
        //TextCtrl()->AppendText(s);
        wxMessageBox(_(s),
               _("Error"),
               wxOK | wxICON_EXCLAMATION, this);
        return(true);
    }
    catch ( ...)
    {
        CloseConnection();
        wxString s;
        wxMessageBox(_("Unhandled exception (in an event handler?)" ),
               _("Exception"),
               wxOK | wxICON_EXCLAMATION, this);


        return true;
    }
}

/*************************************************************************************
void GSIClientTestFrame::OnCloseConnection(wxCommandEvent& WXUNUSED(event))
*************************************************************************************/
void GSIClientTestFrame::OnCloseConnection(wxCommandEvent& WXUNUSED(event))
{
//This can be called from a socket event on a refusal to create a socket.
//In this case m_Client==NULL if we have not got a socket already open
    CloseConnection();
}

/*************************************************************************************
void GSIClientTestFrame::CloseConnection()
*************************************************************************************/
//This needs to close all sockets. User probably needs to be asked if a reset of all nodes
//is required. The Device should certainly be closed
//Really each panel should have its own wxSocketClient so this is really a redundant function
void GSIClientTestFrame::CloseConnection()
{
}
/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_MENU_CLOSE_SESSION
 */

void GSIClientTestFrame::OnGsiIdClientTestMenuCloseSessionClick( wxCommandEvent& event )
{
	event;
    CloseConnection();
}



/**********************************************************************************
void GSIClientFrame::OnGSISocketEvent(wxCommandEvent& event)
The server has sent socket data to the client which has sent this event.
The data is sent as a simple char buffer.

This function should receive GSISocketConnection, GSI_SOCKET_LOST events
GSI_SOCKET_RECORDReceived events will be sent to GSIClientNBPanel or to the event handler
that was specified on creation of GSITestClient object. The GSIClientTestFrame object
is the parent object so handles any events that it's child (NBPanel) doesn't handle
***********************************************************************************/
//void GSIClientTestFrame::OnGSISocketEvent(wxCommandEvent& event)
void GSIClientTestFrame::OnGSISocketEvent(wxGSISocketCommandEvent &event)
{
//This function should really use GetId() in wxEvent class. That way we don't
//have to use the GSISocketData class when posting an event. This is useful
// when we aren't receiving a GSIRecord. For eg. a SOCKET_LOST

//ALSO: Shouldn't we be able to intercept these events in the Notebook panel that
//is actually hosting the socket?
//would save us having to find the panel the socket is in
    wxSocketBase *sock;
	GSISocketData *Sock_Data;

	Sock_Data=(GSISocketData *) event.GetClientData();
    sock=(wxSocketBase *) event.GetClientObject();

    GSIRecord * r=DEBUG_NEW GSIRecord;
//The next line is a kludge. We need to use GetId() rathat than Sock_Data->GetID()
	int id;
	if(Sock_Data)
	{
		id=Sock_Data->GetID();
	}
	else
	{
		id=event.GetId();
	}
	switch (id )
	{
		case GSI_SOCKET_INPUT:
            //TextCtrl()->AppendText(_("GSISocketInput\n"));
            break;
        case GSI_SOCKET_OUTPUT:
            //TextCtrl()->AppendText(_("GSI_SOCKET_OUTPUT\n"));
            break;
        case GSI_SOCKET_CONNECTION:
            //TextCtrl()->AppendText(_("GSISocketConnection\n"));
			m_numSocketConnections++;
			UpdateStatusBar();
            //SetIcon(wxICON(CONN_ICN));
            break;
		case GSI_SOCKET_LOST:     //This doesn't ever appear to be called
			{
            //TextCtrl()->AppendText(_("GSI_SOCKET_LOST\n"));
//When the socket is lost, should we delete the notebook page?
//need to have the node for this page or have the event send its address
				//wxFAIL_MSG("Shouldn't arrive here");
				m_numSocketConnections--;
				//event.GetInt();
				//UpdateNBPage();
				UpdateStatusBar();
				const GSIClientNBPanelData *pd= event.GetNBPanelData();
				UpdateNBPage(*pd);
				//event.Skip();
				//probably need to search all nodes for the Sock adddress and delete them
				//retrieve node from evt
				//SetIcon(wxICON(MONDRIAN));
			}
			break;
        case GSI_SOCKET_RECORD:  //shouldn't arrive here, so send a message to the text box of current notebook patge
            {
                GSIClientNBPanel & panel= *(GSIClientNBPanel* ) m_Notebook->GetCurrentPage();
                GSIClientNBPanelData * const data=panel.GetData();
                data->GetStatusTextCtrl()->AppendText("Unexpected GSI_SOCKET_RECORD event received\n");
            //TextCtrl()->AppendText(_("GSI_SOCKET_RECORD\n"));
            }
            break;
        case GSI_SOCKET_ASYNC_RECORD:
            {
                GSIClientNBPanel & panel= *(GSIClientNBPanel* ) m_Notebook->GetCurrentPage();
                GSIClientNBPanelData * const data=panel.GetData();
                data->GetStatusTextCtrl()->AppendText("Unexpected GSI_SOCKET_ASYNC_RECORD event received\n");
#warning message("Can remove this code, it should be handled by the child of this object")
                if (r->SocketDataToRecord(*Sock_Data))
                {
                    wxString s;
					s=r->MakeInfoString();
					data->GetStatusTextCtrl()->AppendText(s);

                }
                else
                {
                    //GSIStringCANFrame sf;
                    int originNode;
//if not a CAN msg then this will be the origin. If CAN msg then this is the node attached to the device
//node of origin is embedded in the CAN msg and we will overwrite this variable
                    originNode=r->GetNode();

                    wxString s;
					s=r->MakeInfoString();
					data->GetStatusTextCtrl()->AppendText(s);
                }
            }
//originNode holds the node of the originating msg. r->node holds node this message arrived from (the one attached to the device)

            break;
		default:
			break;
	}

	if (Sock_Data)			//Usually a GSIRecord
    {
		delete Sock_Data;
    }
    delete r;

}


/*********************************************************
        void GSIClientTestFrame::UpdateStatusBar()
**********************************************************/
void GSIClientTestFrame::UpdateStatusBar()
{
//bool connected=false;
	wxString s;
	//bool connected=false;

	s.Printf(_("Not connected"));

	if(m_numSocketConnections)
	{
	    //GetPanelData()->GetSocketClient().GetPeer(addr);
	    s.Printf(_("Num socks=%d"), m_numSocketConnections);

		SetIcon(wxICON(CONN_ICN));

    }
    else
        SetIcon(wxICON(MONDRIAN));


    SetStatusText(s, 1);

}
/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_MENU_EXIT
 */

void GSIClientTestFrame::OnGsiIdClientTestMenuExitClick( wxCommandEvent& event )
{
    event;
    Quit();
}


/***********************************************************************/
//  close button 'X' pressed
/***********************************************************************/
void GSIClientTestFrame::OnCloseWindow(wxCloseEvent& event)
{
    Quit();
    event;
}


void GSIClientTestFrame::Quit()
{
    // Before editing this code, remove the block markers.
    ExitDialog* window = DEBUG_NEW ExitDialog(this, ID_EXIT_DIALOG, _("Exit"));
    int returnValue = window->ShowModal();
    int selection=window->m_RadioBox->GetSelection();

    window->Destroy();

    switch(returnValue)
    {
    case wxID_OK:
        if(selection==0)        //exit all node running
        {
            this->Destroy();
        }
        if(selection==1)        //exit reseting this node
        {
            selection++;
            this->Destroy();
        }
        if(selection==2)        //exit resetting all nodes
        {
            selection++;
            this->Destroy();
        }
        break;
    case wxID_CANCEL:
        break;
    }

}



/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_DEBUG_MENU_0
 */

void GSIClientTestFrame::OnGsiIdClientTestDebugMenu0Click( wxCommandEvent& event )
{
#ifdef DEBUG_GSI_SOCKET_EVENT
    //wxCommandEvent eventCustom(wxEVT_GSI_SOCKET_COMMAND);
    wxGSISocketCommandEvent eventCustom(wxEVT_GSI_SOCKET_COMMAND);

	eventCustom.SetSockData( (GSISocketData *)0x1234);
	wxPostEvent(GetEventHandler(), eventCustom);       //handled by: GSITestFrame::OnGSISocketEvent(wxCommandEvent& event)
//won't work because not a wxSocketEvent, which is what OnGSISocketEvent(wxGSISocketCommandEvent &event) is listening for

#endif
	event;
}


/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_DEBUG_MENU_1
 */

void GSIClientTestFrame::OnGsiIdClientTestDebugMenu1Click( wxCommandEvent& event )
{
	event;
    GSIClientNBPanel* window = new GSIClientNBPanel(NULL,0,this, wxID_ANY);
    //GSIClientNBPanel( int node, wxWindow* parent, wxWindowID id = SYMBOL_GSICLIENTNBPANEL_IDNAME, const wxPoint& pos = SYMBOL_GSICLIENTNBPANEL_POSITION, const wxSize& size = SYMBOL_GSICLIENTNBPANEL_SIZE, long style = SYMBOL_GSICLIENTNBPANEL_STYLE );

    window->Show(true);
}



/*!
errorType GSIClientTestFrame::UpdateNBPage(const GSIClientNBPanelData &data)
Using the supplied data object. Setup the notebook page
*/

errorType GSIClientTestFrame::UpdateNBPage(const GSIClientNBPanelData &data)
{
wxString s;
    GSIClientNBPanel & panel= *(GSIClientNBPanel* ) m_Notebook->GetCurrentPage();

    //panel.Update();           can't use update as it resets all control pointers to NULL (it currently calls the ctor Init())

    panel.SetNode(data.GetNodeHandle());
    if(data.GetNodeHandle() == GSI_NODE_NONE)
        s.Printf("none");
    else
        s.Printf("node %i",data.GetNodeHandle());

    m_Notebook->SetPageText(m_Notebook->GetSelection(),s);
   return errNone;
}



/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_MENU_CLOSE_DEVICE
 */

void GSIClientTestFrame::OnGsiIdClientTestMenuCloseDeviceClick( wxCommandEvent& event )
{
	event;

	//GSIClientNBPanel * panel= (GSIClientNBPanel * ) GetNotebook()->GetCurrentPage();
	wxFAIL_MSG("Removed, use new Open/Close functions");
    //CloseDevice(*panel->GetData());


}


/*!
 *errorType GSIClientTestFrame::CloseDevice(GSIClientNBPanelData &pd)
*/
errorType GSIClientTestFrame::CloseDevice(GSIClientNBPanelData &pd)
{
errorType rv=errNone;


GSIClientCommandCloseDeviceXXX CloseDevice(pd.GetSocketClient(),pd.GetDeviceHandle(),pd.GetStatusTextCtrl());

    if(CloseDevice.GetReturnCode() !=  GSISocketReturnData::GSI_SUCCESS)
    {
        int rc=CloseDevice.GetReturnCode();
		if(rc)
		{
			wxString es;
			es=CloseDevice.GetErrorString();

			wxString s="Server returned: ";

			wxMessageBox(_(s+es),
			_("Server returned an error:"),
			wxOK | wxICON_EXCLAMATION, this);
		}
        rv=errFail;
    }
    else
    {       //success
		//we must now remove all nodes on this device from the notebook
		rv=RemoveAllNBPanels(pd.GetDeviceHandle());
        pd.SetDeviceName("none");
        pd.SetDeviceHandle(GSINotAValidDevHandle);

        m_MenuNode->Enable(GSI_ID_CLIENT_TEST_MENU_CLOSE_DEVICE, false);    //disable close, as we are now closed

    }

    return errNone;
}


/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for GSI_ID_CLIENT_TEST_MENU_CLOSE_NODE
 */

void GSIClientTestFrame::OnGsiIdClientTestMenuCloseNodeClick( wxCommandEvent& event )
{
errorType rv=errNone;
GSIClientNBPanel * panel;
GSIClientNBPanelData *pd;

	event;
    panel=(GSIClientNBPanel *)GetNotebook()->GetCurrentPage();
    pd=panel->GetData();

    if(! pd->GetSocketClient().IsConnected())
    {		//if not connected can't remove!
            return;
    }

    CloseNodeDialog* window = DEBUG_NEW CloseNodeDialog(this, GSI_ID_CLIENT_TEST_CLOSE_NODE_DIALOG, _("CloseNode"));

	int returnValue = window->ShowModal();
	GSINodeHandle node=(GSINodeHandle) window->GetNode();		//get node before test so can return cleanly

	window->Destroy();		//destroy the window so can return safely

//Need to ensure that this node is actually open??
    if(returnValue == wxID_OK) //user clicked OK
    {
		wxASSERT(GetNumPanelsOpen() >=0 && m_deviceId != -1);
		pd->SetNodeHandle(node);
        rv=CloseNode(*pd);
        if (rv != errNone) //was (rv != GSISocketReturnData::GSI_SUCCESS)
		{	//server failed to remove node
            return;
		}
    }

}


/*!
 * errorType  GSIClientTestFrame::CloseNode(GSIClientNBPanelData &panel_data)
 *Called by RemoveNode()
 */
errorType  GSIClientTestFrame::CloseNode(GSIClientNBPanelData &panel_data)
{
errorType rv=errNone;

//GSICommandRemoveNode rnCmd(panel_data.GetNodeHandle());
GSIClientCommandRemoveNodeXXX cmd(panel_data.GetSocketClient(),panel_data.GetNodeHandle(),panel_data.GetDeviceHandle(),panel_data.GetStatusTextCtrl());


    if(cmd.GetReturnCode() !=  GSISocketReturnData::GSI_SUCCESS)
    {
        int rc=cmd.GetReturnCode();
		if(rc)
		{
			wxString es;
			es=cmd.GetErrorString();

			wxString s="Server returned: ";

			wxMessageBox(_(s+es),
			_("Server returned an error:"),
			wxOK | wxICON_EXCLAMATION, this);

		}
        panel_data.SetNodeHandle(GSINotAValidNode);
        rv=errFail;
    }
    else
    {   //success
		//m_NBPanelDataArray[panel_data.GetNode()]=NULL;	//though a default class will remain open??
        //panel_data.SetNode(GSINotAValidNodeHandle);
		RemoveNBPanel(panel_data.GetNodeHandle());
    }
//m_NBPanelDataArray[panel_data.GetNode()]=NULL;	//though a default class will remain open??
 //panel_data.SetNode(GSINotAValidNodeHandle);

//	UpdateNBPage(panel_data);
//	m_numPanelsOpen--;
    return rv;
}

/*!
 *errorType RemoveAllNBPanels(GSIDeviceHandle h_dev)	//remove all nodes attached to this device
*/

errorType GSIClientTestFrame::RemoveAllNBPanels(GSIDevHandle h_dev)	//remove all nodes attached to this device
{
const wxNotebook &nb = *GetNotebook();
	size_t num=nb.GetPageCount();
	for(size_t i=0;i<num;i++)
	{
		GSIClientNBPanel *panel=(GSIClientNBPanel *) nb.GetPage(i);
		GSIClientNBPanelData &pd=*panel->GetData();
		if(pd.GetDeviceHandle() == h_dev)
		{
			RemoveNBPanel(pd.GetNodeHandle());
		}
	}

	return errNone;
}

/*!
*errorType GSIClientTestFrame::RemoveNBPanel(pd.GetNode()
*/

errorType GSIClientTestFrame::RemoveNBPanel(GSINodeHandle h_node)
{
	wxASSERT(h_node >0 && h_node <= GSIMaxNumNodeHandles ||h_node==GSINotAValidNode);

	if(h_node<0 || h_node >GSIMaxNumNodeHandles)
		return errRange;

	GSIClientNBPanelData *pd=m_NBPanelDataArray[h_node];
	const wxNotebook &nb = *GetNotebook();
	size_t num=nb.GetPageCount();
	//now check all the pages looking for this PanelData class
	for(size_t i=0;i<num;i++)
	{
		GSIClientNBPanel *panel=(GSIClientNBPanel *) nb.GetPage(i);
		if(panel->GetData() == pd)
		{//ok the panel data matches panel data of the node to remove
			m_NBPanelDataArray[panel->GetNode()]=NULL;
			if(GetNumPanelsOpen() > 1)		//don't remove last panel
			{
				m_Notebook->RemovePage(i);
				m_numPanelsOpen--;				//keep track of number open
			}
			pd->SetNodeHandle(GSINotAValidNodeHandle); //no node
			//pd->SetDeviceHandle(GSINotAValidDevHandle);
		}
	}

	UpdateNBPage(*pd);

	return errNone;
}

/*!
*errorType GSIClientTestFrame::AddNBPanel(GSIClientNBPanelData & pd)
*/

errorType GSIClientTestFrame::AddNBPanel(GSIClientNBPanelData & pd)
{
	wxString s;
	GSIClientNBPanel *panel;
	GSINodeHandle hNode=pd.GetNodeHandle();

	if(hNode <0 || hNode >= GSIMaxNumNodeHandles)
		return errRange;

	if(m_NBPanelDataArray[hNode])
	{
		//already a node here
		return errAlreadyOpen;
	}

    if(GetNumPanelsOpen()==0)   //noNodesOpen means this is a blank Notepad panel
    {
        panel = (GSIClientNBPanel *) m_Notebook->GetCurrentPage();   //find the panel
    }
    else //a node is already open, so open another
    {
    //Instantiate the associated panelData class and send it to the NBPanel
        panel = DEBUG_NEW GSIClientNBPanel(NULL,hNode, m_Notebook, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSUNKEN_BORDER|wxTAB_TRAVERSAL );
    }

    s.Printf(_("Node %i"),pd.GetNodeHandle());
    if(GetNumPanelsOpen() != 0)
        m_Notebook->AddPage(panel, s);      //don't add if this is the default panel
    m_NBPanelDataArray[hNode]=panel->GetData();
	m_numPanelsOpen++;
	wxASSERT_MSG(m_numPanelsOpen < (size_t) GSIMaxNumNodeHandles && m_numPanelsOpen >0,"Error with m_numPanelsOpen");

	return errNone;
}

/******************************************************************************************
errorType GSIClientTestFrame GSIClientNBPanelData *GetPanelData(GSINodeHandle=GSI_NODE_THIS)
*******************************************************************************************/
GSIClientNBPanelData * GSIClientTestFrame::GetPanelData(GSINodeHandle node_handle)
{
	if(node_handle == GSINotAValidNodeHandle)
		return NULL;
	if (m_NBPanelDataArray[node_handle]==NULL)
	{
		//return the current page, though not sure this is a good idea!
		//allows use of panel without access to the hardware (which we have yet to test for)
		//as long as caller updates its copy of the panel * (or later accesses hardware through this panel)
		//then all should be well
		GSIClientNBPanel * panel;
		GSIClientNBPanelData *pd;

		panel=(GSIClientNBPanel *)GetNotebook()->GetCurrentPage();
		pd=panel->GetData();

		return(pd);
	}
	return(m_NBPanelDataArray[node_handle]);
}


/*!
bool GSIClientTestFrame::IsNodeOpen(GSINodeHandle h)
*/

bool GSIClientTestFrame::IsNodeOpen(GSINodeHandle h)
{
const GSIClientNBPanelData * p;
	p=(const GSIClientNBPanelData *)GetPanelData(h);
	if(p)
	{
		GSINodeHandle n=p->GetNodeHandle();
		n;
		return(p->GetNodeHandle()!=GSINotAValidNodeHandle);
	}
	return false;
}




/*!
bool GSIClientTestFrame::IsDeviceOpen(const wxString &dev_str)
*/

bool GSIClientTestFrame::IsDeviceOpen(const wxString &dev_str)
{
GSIDevices Devices;
GSIDevHandle hDev;
const GSIClientNBPanelData * p;

	hDev=Devices.GetDeviceHandle(dev_str);
	if(hDev==GSINotAValidDevHandle)
		return false;

	p=(const GSIClientNBPanelData *)GetPanelData();
	if(p)
	{
		return(p->GetDeviceHandle()!=GSINotAValidDevHandle);
	}
	return false;
}
/*!
bool GSIClientTestFrame::IsDeviceOpen(GSIDevHandle h)
*/

bool GSIClientTestFrame::IsDeviceOpen(GSIDevHandle h)
{
const GSIClientNBPanelData * p;
	p=(const GSIClientNBPanelData *)GetPanelData(h);
	if(p)
	{
		return(p->GetDeviceHandle()!=GSINotAValidDevHandle);
	}
	return false;
}
