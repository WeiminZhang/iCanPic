/*****************************************************************************
*	GSI a socket interface for Micro-controllers and Controller Area Network *
*   Copyright (C) 2014 Glenn Self                                            *
*                                                                            *
*   This program is free software: you can redistribute it and/or modify     *
*   it under the terms of the GNU General Public License as published by     *
*   the Free Software Foundation, either version 3 of the License, or        *
*   (at your option) any later version.                                      *
*                                                                            *
*    This program is distributed in the hope that it will be useful,         *
*    but WITHOUT ANY WARRANTY; without even the implied warranty of          *
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
*    GNU General Public License for more details.                            *
*                                                                            *
*    You should have received a copy of the GNU General Public License       *
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
*****************************************************************************/


// Generated by DialogBlocks (Personal Edition), 02/03/2007 11:50:48

#if defined(__GNUG__) && !defined(NO_GCC_PRAGMA)
#pragma implementation "GSIClientNBPanel.h"
#endif

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

#if __VISUALC__
	#ifdef _DEBUG
		#define _CRTDBG_MAP_ALLOC
		#include <crtdbg.h>
		#define DEBUG_NEW new(_NORMAL_BLOCK ,__FILE__, __LINE__)
	#else
		#define DEBUG_NEW new
	#endif
#endif

#if __GNUC__
    #define DEBUG_NEW new
#endif

////@begin includes
////@end includes

//#include "../socket/gsi.hpp"
//#include "../socket/socket.hpp"
//#include "client.hpp"

#include "GSIClientNBPanel.h"
#include "OpenSocketSession.h"
#include "client.hpp"
#include "gsi-common/include/record.hpp"
#include "gsi-common/include/rs232defs.h"

////@begin XPM images
////@end XPM images

/*!
 * GSIClientNBPanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS(GSIClientNBPanel, wxPanel )
IMPLEMENT_DYNAMIC_CLASS(GSIClientNBPanelData, wxObject)
/*!
 * GSIClientNBPanel event table definition
 */

BEGIN_EVENT_TABLE( GSIClientNBPanel, wxPanel )

////@begin GSIClientNBPanel event table entries
    EVT_COMBOBOX( ID_COMBOBOX, GSIClientNBPanel::OnComboboxSelected )
    EVT_TEXT_ENTER( ID_COMBOBOX, GSIClientNBPanel::OnComboboxEnter )

    EVT_COMBOBOX( ID_COMBOBOX1, GSIClientNBPanel::OnCombobox1Selected )
    EVT_TEXT_ENTER( ID_COMBOBOX1, GSIClientNBPanel::OnCombobox1Enter )

    EVT_BUTTON( ID_KEY_BUTTON0, GSIClientNBPanel::OnKeyButton0Click )

////@end GSIClientNBPanel event table entries
	//Let the individual panels (one for each node) handle socket events sent to their socket
    EVT_GSI_SOCKET_RECORD_RECEIVED(wxID_ANY, GSIClientNBPanel::OnGSISocketEvent)			//custom event from GSIClient
	EVT_GSI_SOCKET_COMMAND(wxID_ANY, GSIClientNBPanel::OnGSISocketCommand)
	//EVT_GSI_SOCKET_COMMAND(wxID_ANY, GSIClientNBPanel::OnGSISocketCommand)			//custom event from GSIClient

END_EVENT_TABLE()

/*!
 * GSIClientNBPanel constructors
 */

GSIClientNBPanel::GSIClientNBPanel()
{
    wxFAIL_MSG("Need to obtain node from caller for two step construction");
    m_node=0;

    Init(NULL);
}

GSIClientNBPanel::GSIClientNBPanel(GSIClientNBPanelData *data, int node, wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
    m_node=node;
    Init(data);
    Create(parent, id, pos, size, style);
}

/*!
 * GSIClientNBPanel creator
 */

bool GSIClientNBPanel::Create(  wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin GSIClientNBPanel creation
    wxPanel::Create( parent, id, pos, size, style );

    CreateControls();
    Centre();
////@end GSIClientNBPanel creation

    m_Data.SetAllCommandCB(m_AllCommandCB);
    //m_Data.SetKey()
    m_Data.SetLCDCommandCB(m_LCDCommandCB);
    m_Data.SetLCDTextCtrl(m_LCDTextCtrl);
    m_Data.SetNodeHandle(m_node);
    m_Data.SetStatusTextCtrl(m_StatusTextCtrl);
    m_Data.SetKey(0,m_Key0);
    m_Data.SetKey(1,m_Key1);
    m_Data.SetKey(2,m_Key2);
    m_Data.SetKey(3,m_Key3);
    m_Data.SetKey(4,m_Key4);
    m_Data.SetKey(5,m_Key5);
    m_Data.SetKey(6,m_Key6);
    m_Data.SetKey(7,m_Key7);
    m_Data.SetKey(8,m_Key8);
    m_Data.SetKey(9,m_Key9);
    m_Data.SetKey(10,m_Key10);
    m_Data.SetKey(11,m_Key11);

    m_Data.SetStaticTextDeviceName(m_StaticTextDeviceName);

    return true;
}

/*!
 * GSIClientNBPanel destructor
 */

GSIClientNBPanel::~GSIClientNBPanel()
{
////@begin GSIClientNBPanel destruction
////@end GSIClientNBPanel destruction

    GetData()->GetSocketClient().Destroy();
}

/*!
 * Member initialisation
 */

void GSIClientNBPanel::Init(GSIClientNBPanelData *data)
{
////@begin GSIClientNBPanel member initialisation
    m_SplitterWindow = NULL;
    m_Panel = NULL;
    m_LCDCommandCB = NULL;
    m_AllCommandCB = NULL;
    m_Key0 = NULL;
    m_Key1 = NULL;
    m_Key2 = NULL;
    m_Key3 = NULL;
    m_Key4 = NULL;
    m_Key5 = NULL;
    m_Key6 = NULL;
    m_Key7 = NULL;
    m_Key8 = NULL;
    m_Key9 = NULL;
    m_Key10 = NULL;
    m_Key11 = NULL;
    m_StaticTextDeviceName = NULL;
    m_LCDTextCtrl = NULL;
    m_StatusTextCtrl = NULL;
////@end GSIClientNBPanel member initialisation
    m_Data.SetSocketClient(NULL);
    if(data)        //set data class with data sent from caller
    {
        m_Data=*data;       //overwrite our data with callers data

        if(m_node >=0 && m_node < GSIMaxNumNodes)
            m_Data.SetNodeHandle(m_node);
    }

//Instantiate the socket client. If we want it to print messages to m_StatusTextCtrl, send it as a 2nd parameter
//evt_handler is set to this *
    GetData()->SetSocketClient(DEBUG_NEW GSITestClient(*this));

    wxString s;
    s=m_Data.GetDeviceName();
    if(s.IsEmpty())
    {
        s="Device:none";
    }
}
/*!
 * Control creation for GSIClientNBPanel
 */

void GSIClientNBPanel::CreateControls()
{
////@begin GSIClientNBPanel content construction
    // Generated by DialogBlocks, 30/03/2008 11:36:51 (Personal Edition)

    GSIClientNBPanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    m_SplitterWindow = new wxSplitterWindow( itemPanel1, ID_SPLITTERWINDOW, wxDefaultPosition, wxSize(100, 100), wxSP_3DBORDER|wxSP_3DSASH|wxNO_BORDER );
    m_SplitterWindow->SetMinimumPaneSize(0);

    m_Panel = new wxPanel( m_SplitterWindow, ID_PANEL1, wxDefaultPosition, wxDefaultSize, wxSUNKEN_BORDER|wxTAB_TRAVERSAL );
    wxBoxSizer* itemBoxSizer5 = new wxBoxSizer(wxVERTICAL);
    m_Panel->SetSizer(itemBoxSizer5);

    wxStaticBox* itemStaticBoxSizer6Static = new wxStaticBox(m_Panel, wxID_ANY, _("Enter GSI commands"));
    wxStaticBoxSizer* itemStaticBoxSizer6 = new wxStaticBoxSizer(itemStaticBoxSizer6Static, wxHORIZONTAL);
    itemBoxSizer5->Add(itemStaticBoxSizer6, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);
    wxBoxSizer* itemBoxSizer7 = new wxBoxSizer(wxHORIZONTAL);
    itemStaticBoxSizer6->Add(itemBoxSizer7, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
    wxBoxSizer* itemBoxSizer8 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer7->Add(itemBoxSizer8, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
    wxStaticText* itemStaticText9 = new wxStaticText( m_Panel, ID_STATICTEXT, _("LCD commands"), wxDefaultPosition, wxDefaultSize, 0 );
    if (ShowToolTips())
        itemStaticText9->SetToolTip(_("Enter commands to display on node's LCD"));
    itemBoxSizer8->Add(itemStaticText9, 0, wxALIGN_LEFT|wxALL, 5);

    wxArrayString m_LCDCommandCBStrings;
    m_LCDCommandCB = new wxComboBox( m_Panel, ID_COMBOBOX, _("NULL"), wxDefaultPosition, wxDefaultSize, m_LCDCommandCBStrings, wxCB_DROPDOWN );
    m_LCDCommandCB->SetStringSelection(_("NULL"));
    itemBoxSizer8->Add(m_LCDCommandCB, 0, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer11 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer7->Add(itemBoxSizer11, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
    wxStaticText* itemStaticText12 = new wxStaticText( m_Panel, wxID_STATIC, _("All commands"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer11->Add(itemStaticText12, 0, wxALIGN_LEFT|wxALL, 5);

    wxArrayString m_AllCommandCBStrings;
    m_AllCommandCB = new wxComboBox( m_Panel, ID_COMBOBOX1, _("NULL"), wxDefaultPosition, wxDefaultSize, m_AllCommandCBStrings, wxCB_DROPDOWN );
    m_AllCommandCB->SetStringSelection(_("NULL"));
    itemBoxSizer11->Add(m_AllCommandCB, 0, wxGROW|wxALL, 5);

    itemBoxSizer5->Add(5, 5, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer15 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer5->Add(itemBoxSizer15, 0, wxALIGN_LEFT|wxALL, 5);
    itemBoxSizer15->Add(5, 5, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxStaticBox* itemStaticBoxSizer17Static = new wxStaticBox(m_Panel, wxID_ANY, _("Keypad"));
    wxStaticBoxSizer* itemStaticBoxSizer17 = new wxStaticBoxSizer(itemStaticBoxSizer17Static, wxVERTICAL);
    itemBoxSizer15->Add(itemStaticBoxSizer17, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
    wxBoxSizer* itemBoxSizer18 = new wxBoxSizer(wxHORIZONTAL);
    itemStaticBoxSizer17->Add(itemBoxSizer18, 0, wxALIGN_LEFT|wxALL, 5);
    m_Key0 = new wxButton( m_Panel, ID_KEY_BUTTON0, _("1"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key0->SetDefault();
    m_Key0->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer18->Add(m_Key0, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Key1 = new wxButton( m_Panel, ID_KEY_BUTTON1, _("2"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key1->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer18->Add(m_Key1, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Key2 = new wxButton( m_Panel, ID_KEY_BUTTON2, _("3"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key2->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer18->Add(m_Key2, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer22 = new wxBoxSizer(wxHORIZONTAL);
    itemStaticBoxSizer17->Add(itemBoxSizer22, 0, wxALIGN_LEFT|wxALL, 5);
    m_Key3 = new wxButton( m_Panel, ID_KEY_BUTTON3, _("4"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key3->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer22->Add(m_Key3, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Key4 = new wxButton( m_Panel, ID_KEY_BUTTON4, _("5"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key4->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer22->Add(m_Key4, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Key5 = new wxButton( m_Panel, ID_KEY_BUTTON5, _("6"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key5->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer22->Add(m_Key5, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer26 = new wxBoxSizer(wxHORIZONTAL);
    itemStaticBoxSizer17->Add(itemBoxSizer26, 0, wxALIGN_LEFT|wxALL, 5);
    m_Key6 = new wxButton( m_Panel, ID_KEY_BUTTON6, _("7"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key6->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer26->Add(m_Key6, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Key7 = new wxButton( m_Panel, ID_KEY_BUTTON7, _("8"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key7->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer26->Add(m_Key7, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Key8 = new wxButton( m_Panel, ID_KEY_BUTTON8, _("9"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key8->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer26->Add(m_Key8, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer30 = new wxBoxSizer(wxHORIZONTAL);
    itemStaticBoxSizer17->Add(itemBoxSizer30, 0, wxALIGN_LEFT|wxALL, 5);
    m_Key9 = new wxButton( m_Panel, ID_KEY_BUTTON9, _("0"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key9->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer30->Add(m_Key9, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Key10 = new wxButton( m_Panel, ID_KEY_BUTTON10, _("*"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key10->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer30->Add(m_Key10, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Key11 = new wxButton( m_Panel, ID_KEY_BUTTON11, _("#"), wxDefaultPosition, wxSize(30, -1), 0 );
    m_Key11->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer30->Add(m_Key11, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    itemBoxSizer15->Add(5, 5, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxStaticBox* itemStaticBoxSizer35Static = new wxStaticBox(m_Panel, wxID_ANY, _("Device"));
    wxStaticBoxSizer* itemStaticBoxSizer35 = new wxStaticBoxSizer(itemStaticBoxSizer35Static, wxHORIZONTAL);
    itemBoxSizer15->Add(itemStaticBoxSizer35, 0, wxALIGN_TOP|wxALL, 5);
    m_StaticTextDeviceName = new wxStaticText( m_Panel, wxID_STATIC_DEVICE_NAME, _("Device:none"), wxDefaultPosition, wxDefaultSize, 0 );
    itemStaticBoxSizer35->Add(m_StaticTextDeviceName, 0, wxALIGN_TOP|wxALL, 5);

    itemBoxSizer5->Add(5, 5, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxStaticBox* itemStaticBoxSizer38Static = new wxStaticBox(m_Panel, wxID_ANY, _("LCD (on node)"));
    wxStaticBoxSizer* itemStaticBoxSizer38 = new wxStaticBoxSizer(itemStaticBoxSizer38Static, wxVERTICAL);
    itemBoxSizer5->Add(itemStaticBoxSizer38, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);
    m_LCDTextCtrl = new wxTextCtrl( m_Panel, ID_TEXTCTRL, _("012356789012345"), wxDefaultPosition, wxSize(300, 50), wxTE_READONLY );
    itemStaticBoxSizer38->Add(m_LCDTextCtrl, 0, wxGROW|wxALL, 5);

    itemBoxSizer5->Add(5, 5, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    m_StatusTextCtrl = new wxTextCtrl( m_SplitterWindow, ID_TEXTCTRL1, _T(""), wxDefaultPosition, wxSize(90, 90), wxTE_MULTILINE|wxNO_BORDER );

    m_SplitterWindow->SplitHorizontally(m_Panel, m_StatusTextCtrl, 600);
    itemBoxSizer2->Add(m_SplitterWindow, 1, wxGROW|wxALL, 5);

////@end GSIClientNBPanel content construction



}

#if 0
/*!
 * wxEVT_COMMAND_COMBOBOX_SELECTED event handler for GSI_ID_CLIENT_TEST_NB_COMBOBOX_LCD
 */

void GSIClientNBPanel::OnGsiIdClientTestNbComboboxLcdSelected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_COMBOBOX_SELECTED event handler for GSI_ID_CLIENT_TEST_NB_COMBOBOX_LCD in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_COMBOBOX_SELECTED event handler for GSI_ID_CLIENT_TEST_NB_COMBOBOX_LCD in GSIClientNBPanel.
}

/*!
 * wxEVT_COMMAND_TEXT_ENTER event handler for GSI_ID_CLIENT_TEST_NB_COMBOBOX_LCD
 */

void GSIClientNBPanel::OnGsiIdClientTestNbComboboxLcdEnter( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_TEXT_ENTER event handler for GSI_ID_CLIENT_TEST_NB_COMBOBOX_LCD in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_TEX_ENTER event handler for GSI_ID_CLIENT_TEST_NB_COMBOBOX_LCD in GSIClientNBPanel.
}

/*!
 * wxEVT_COMMAND_COMBOBOX_SELECTED event handler for GSI_ID_CLIENT_TEST_NB_COMBO_BOX_ALL
 */

void GSIClientNBPanel::OnGsiIdClientTestNbComboBoxAllSelected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_COMBOBOX_SELECTED event handler for GSI_ID_CLIENT_TEST_NB_COMBO_BOX_ALL in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_COMBOBOX_SELECTED event handler for GSI_ID_CLIENT_TEST_NB_COMBO_BOX_ALL in GSIClientNBPanel.
}

/*!
 * wxEVT_COMMAND_TEXT_ENTER event handler for GSI_ID_CLIENT_TEST_NB_COMBO_BOX_ALL
 */

void GSIClientNBPanel::OnGsiIdClientTestNbComboBoxAllEnter( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_TEXT_ENTER event handler for GSI_ID_CLIENT_TEST_NB_COMBO_BOX_ALL in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_TEXT_ENTER event handler for GSI_ID_CLIENT_TEST_NB_COMBO_BOX_ALL in GSIClientNBPanel.
}

/*!
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for GSI_ID_CLIENT_TEST_KD_BUTTON1
 */

void GSIClientNBPanel::OnGsiIdClientTestKdButton1Click( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for GSI_ID_CLIENT_TEST_KD_BUTTON1 in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for GSI_ID_CLIENT_TEST_KD_BUTTON1 in GSIClientNBPanel.
}

#endif

/*!
 * Should we show tooltips?
 */

bool GSIClientNBPanel::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap GSIClientNBPanel::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin GSIClientNBPanel bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end GSIClientNBPanel bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon GSIClientNBPanel::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin GSIClientNBPanel icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end GSIClientNBPanel icon retrieval
}
/*!
 * wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX
 */

void GSIClientNBPanel::OnComboboxSelected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX in GSIClientNBPanel.
}

/*!
 * wxEVT_COMMAND_TEXT_ENTER event handler for ID_COMBOBOX
 */

void GSIClientNBPanel::OnComboboxEnter( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_TEXT_ENTER event handler for ID_COMBOBOX in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_TEXT_ENTER event handler for ID_COMBOBOX in GSIClientNBPanel.
}

/*!
 * wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX1
 */

void GSIClientNBPanel::OnCombobox1Selected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX1 in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_COMBOBOX_SELECTED event handler for ID_COMBOBOX1 in GSIClientNBPanel.
}

/*!
 * wxEVT_COMMAND_TEXT_ENTER event handler for ID_COMBOBOX1
 */

void GSIClientNBPanel::OnCombobox1Enter( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_TEXT_ENTER event handler for ID_COMBOBOX1 in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_TEXT_ENTER event handler for ID_COMBOBOX1 in GSIClientNBPanel.
}

/*!
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_BUTTON
 */

void GSIClientNBPanel::OnKeyButton0Click( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_BUTTON in GSIClientNBPanel.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_BUTTON in GSIClientNBPanel.
}

#if 0
const wxButton   *GSIClientNBPanel::GetKey(int k) const
{
    wxASSERT_MSG(k<0 || k >= GSIMaxNumKeypadKeys,"keypad request out of range");

    if(k<0 || k >= GSIMaxNumKeypadKeys)
        return NULL;

    return m_Key[k];

}

#endif


/*!
 *errorType GSIClientNBPanel::SetNode(int node)
 */
errorType GSIClientNBPanel::SetNode(int node)
{
    wxASSERT_MSG(node == GSINotAValidNodeHandle || (node >=0 && node < GSIMaxNumNodes),"invalid node value (out of range)");

    if(node != GSINotAValidNodeHandle && (node < 0 || node >= GSIMaxNumNodes))
        return errRange;

    m_node = node;

   return errNone;
}


//Ask the server for another socket
errorType GSIClientNBPanel::OpenSocket()
{
errorType rv=errNone;

    OpenSocketsession* window = DEBUG_NEW OpenSocketsession(this, GSI_ID_CLIENT_TEST_OPEN_SOCKET_SESSION, _("Open Socket session"));
	window->SetFocus();
    int returnValue = window->ShowModal();
    if(returnValue == wxID_OK)
    {
        int addr=window->GetAddressInt();
        wxString domain=window->GetAddressString();

        if(GetData()->GetSocketClient().ConnectToServer(addr,domain))
        {
			rv=errSocketNoHost;
        }

    }
    window->Destroy();
    return rv;
}



/*!
 * GSIClientNBPanelData default ctor
 *using the default data object. Setup the notebook page
 */

void GSIClientNBPanel::Update()
{
    Init(GetData());
}

/*!********************** Start of GSIClientNBPanelData *********************************************

 * GSIClientNBPanelData default ctor
 */

GSIClientNBPanelData::GSIClientNBPanelData()
{
    m_StatusText=NULL;
    m_LCDText=NULL;
    m_LCDCommandCB=NULL;
    m_AllCommandCB=NULL;
    m_node= GSI_NODE_NONE;
    m_deviceHandle=GSINotAValidDevHandle;
    m_deviceChoiceId=0;
}

/*!
 * GSIClientNBPanelData ctor
 */

GSIClientNBPanelData::GSIClientNBPanelData(const GSIClientNBPanelData &data)
: wxObject()
{
    (*this) = data;
}



/*!
 * GSIClientNBPanelData default dtor
 */

GSIClientNBPanelData::~GSIClientNBPanelData()
{

}



/*!
 * GSIClientNBPanelData copy operator
 */

void GSIClientNBPanelData::operator=(const GSIClientNBPanelData& data)
{
    m_StatusText=data.m_StatusText;
    m_LCDText=data.m_LCDText;
    m_LCDCommandCB=data.m_LCDCommandCB;
    m_AllCommandCB=data.m_AllCommandCB;

    for(int i=0;i<GSIMaxNumKeypadKeys;i++)
    {
        m_Key[i]=data.GetKey(i);
    }

}


/*!
 *  GSIClientNBPanelData Get/Set functions for data members
 */

void GSIClientNBPanelData::SetKey(int i,wxButton  *const b)
{
    wxASSERT_MSG (i>=0 && i < GSIMaxNumKeypadKeys,"key out of range");

    if(i<0 || i >= GSIMaxNumKeypadKeys)
        return;

    m_Key[i]=b;
}



wxButton *const GSIClientNBPanelData::GetKey(int k) const
{
    wxASSERT_MSG(k>=0 && k <= GSIMaxNumKeypadKeys,"keypad request out of range");

    if(k<0 || k >= GSIMaxNumKeypadKeys)
        return NULL;

    return m_Key[k];

}


/*!
 *errorType GSIClientNBPanelData::SetNode(int node)
 */
errorType GSIClientNBPanelData::SetNodeHandle(GSINodeHandle node)
{
    wxASSERT_MSG( (node == GSINotAValidNode) ||( node >=0 && node < GSIMaxNumNodes ) ,"invalid node value (out of range)");


    if(node < 0 || node >= GSIMaxNumNodes)
    {
        m_node=GSINotAValidNode;
        return errRange;
    }
    m_node = node;

   return errNone;
}


/*!
 *void GSIClientNBPanelData::SetDeviceName(const wxString & dev)
 */

void GSIClientNBPanelData::SetDeviceName(const wxString & dev)
{

    m_DeviceStr=dev;
    wxString s="Device:"+dev;
    GetStaticTextDeviceName()->SetLabel(s);
}

/*!
 *errorType GSIClientNBPanelData::SetDeviceHandle(GSIHandle device_handle)
 */

errorType GSIClientNBPanelData::SetDeviceHandle(GSIHandle device_handle)
{
    if(device_handle <0 || device_handle >= GSIMaxNumDeviceHandles)
        device_handle=GSINotAValidDevHandle;

    m_deviceHandle=device_handle;
    return errNone;
}


/**********************************************************************************
void GSIClientFrame::OnGSISocketEvent(wxCommandEvent& event)
The server has sent socket data to the client which has sent this event.
The data is sent as a simple char buffer.

***********************************************************************************/
//void GSIClientTestFrame::OnGSISocketEvent(wxCommandEvent& event)
void GSIClientNBPanel::OnGSISocketEvent(wxGSISocketCommandEvent &event)
{
    wxSocketBase *sock;
	GSISocketData *Sock_Data;

	Sock_Data=(GSISocketData *) event.GetClientData();
    sock=(wxSocketBase *) event.GetClientObject();
   GSIRecord * r=DEBUG_NEW GSIRecord;

    int id=Sock_Data->GetID();
	switch (id )
	{
		case GSI_SOCKET_INPUT:
            //TextCtrl()->AppendText(_("GSI_SOCKET_INPUT\n"));
            m_StatusTextCtrl->AppendText(_("GSI_SOCKET_INPUT\n"));
            break;
        case GSI_SOCKET_OUTPUT:
            //TextCtrl()->AppendText(_("GSI_SOCKET_OUTPUT\n"));
            m_StatusTextCtrl->AppendText(_("GSI_SOCKET_OUTPUT\n"));
            break;
        case GSI_SOCKET_CONNECTION:
            //TextCtrl()->AppendText(_("GSI_SOCKET_CONNECTION\n"));
            event.Skip(true);
            m_StatusTextCtrl->AppendText("Received an unexpected GSI_SOCKET_CONNECTION event");
            return;
            break;
		case GSI_SOCKET_LOST:     //This doesn't ever appear to be called
            //TextCtrl()->AppendText(_("GSI_SOCKET_LOST\n"));
            event.Skip(true);
            m_StatusTextCtrl->AppendText("Received an unexpected GSI_SOCKET_LOST event");
            return;
			break;
        case GSI_SOCKET_RECORD:
            //TextCtrl()->AppendText(_("GSI_SOCKET_RECORD\n"));
            break;
        case GSI_SOCKET_ASYNC_RECORD:
            {
                if (r->SocketDataToRecord(*Sock_Data))
                {
                    //error
                    m_StatusTextCtrl->AppendText(_("GSI_SOCKET_ASYNC_RECORD: ERROR reading record!\n"));
                }
                else
                {
                    //GSIStringCANFrame sf;
                    int originNode;
//if not a CAN msg then this will be the origin. If CAN msg then this is the node attached to the device
//node of origin is embedded in the CAN msg and we will overwrite this variable
                    originNode=r->GetNode();

                    wxString s;
					s=r->MakeInfoString();
					GetData()->GetStatusTextCtrl()->AppendText(s);
                }
            }
//originNode holds the node of the originating msg. r->node holds node this message arrived from (the one attached to the device)

            break;
		default:
			break;
	}

	if (Sock_Data)			//Usually a GSIRecord usu
    {
#warning ("Here!")
    //SetClientObject(NULL) should also delete any object here
#if 1
		delete Sock_Data;
        //event.SetClientObject(NULL);        //custom event dtor will delete otherwise!
#endif
    }
    delete r;

}

/**********************************************************************************
void GSIClientFrame::OnGSISocketCommand(wxCommandEvent& event)
The server has sent socket data to the client which has sent this event.
The data is sent as a simple char buffer.

***********************************************************************************/
//void GSIClientNBPanel::OnGSISocketCommand(wxCommandEvent& event)


//Not sure if this is the correct place to field this event.
//The higher level function needs to keep track of which nodes are attached
//needs to allocate/deallocate NB pages etc.


void GSIClientNBPanel::OnGSISocketCommand(wxGSISocketCommandEvent &event)
{
    wxSocketBase *sock;
	GSISocketData *Sock_Data;

	Sock_Data=(GSISocketData *) event.GetClientData();
	sock;
	int id=event.GetId();
	switch(id)
	{
	case GSI_SOCKET_LOST:     //This doesn't ever appear to be called
		{
			GSIClientNBPanelData *const pd= GetData();
			//CloseSocket();		//write this function, update the panel variables
//Remove the next line
			pd->GetSocketClient().CloseSocket();
			//ClientData is already used to store GSISocketData *
			event.SetNBPanelData(pd);
			event.Skip();	//allow GSIClientTestFrame to do any processing also
		}
		break;
	default:
		event.Skip();
		break;
	}

}

#if 0
//?? Should make GSIClientNBPanel into a GSIClientNode class
//each Node would be a NB page with a socket, a node etc.
//Why did I use this NBData class anyway??
//Deleting a NB page should then delete socket etc.
//Each NBPage/Node would then talk to the server, open a device/HdwNode
//If device already open on Server then no problem.
//If node already in use, also should be no problem. The server would then
//send/receive data for this Hdw node from multiple clients. Could be tricky
//so server would need to send a warning error.
errorType GSIClientNBPanel::CloseSocket()
{
GSISocketData * SockData =NULL;
    GetGSISocketClient->Close();
    m_open=false;
//Now notify the GSISocketClientTest class if there is one
#warning ("This event has probably already been sent by the socket event handler")
    SockData= DEBUG_NEW GSISocketData(GSI_SOCKET_LOST);       //this will be deleted by the handler, what if there isn't one?!
#ifndef DEBUG_GSI_SOCKET_EVENT
	wxCommandEvent eventCustom(wxEVT_GSI_SOCKET_COMMAND);

	eventCustom.SetClientObject((wxClientData *)SockData);
	wxPostEvent(&m_EventHandler, eventCustom);       //handled by: GSITestFrame::OnGSISocketEvent(wxCommandEvent& event)
#endif
    return errNone;
}
#endif
